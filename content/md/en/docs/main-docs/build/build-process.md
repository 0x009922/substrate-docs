---
title: Build process
description: Describes how a Substrate node is compiled into platform-native and WebAssembly binaries and how the binaries are used to execute calls into the Substrate runtime.
keywords:
---

In [Architecture](/main-docs/fundamentals/architecture), you learned that a Substrate node consists of an outer node host and a runtime execution environment.
These node components communicate with each other through runtime API calls and host function calls.
In this section, you'll learn more about how the Substrate runtime is compiled into a platform-native executable and into a WebAssembly (Wasm) binary that is stored on the blockchain.
After you see the inner-working of how the binaries are compiled, you'll learn more about why there are two binaries, when they are used, and how you can change the execution strategies, if you need to.

## Compiling an optimized artifact

You probably already know that you can compile a Substrate node by running the `cargo build --release` command in the root directory for a Substrate node project.
This command builds both the platform-specific executable and Wasm binaries for the project in the local directory and produces an **optimized** executable artifact.
Producing the optimized executable artifact includes some post-compilation processing.

As part of the optimization process, the Wasm runtime binary is compiled and compressed through a series of internal steps before it's included in the genesis state for a chain.
To give you a better understanding of the process, the following diagram summarizes the steps.

![WebAssembly compiled and compressed before included on-chain](/media/images/docs/main-docs/node-executable.png)

The following sections describe the build process in more detail.

### Build the initial Wasm binary

The `wasm-builder` is a tool that integrates the process of building the WebAssembly binary for your project into the main `cargo` build process.
This tool is published in the `substrate-wasm-builder` crate.

- Cargo builds a dependency graph from all of the `Cargo.toml` in the project.
- The runtime `build.rs` module uses the `substrate-wasm-builder` crate to compile the Rust code for the runtime into a Wasm binary, creating the initial binary artifact.

### Compact the initial binary

- The `substrate-wasm-builder` wasm linker invokes [wasm-opt](https://www.npmjs.com/package/wasm-opt).
- The [wasm-opt](https://www.npmjs.com/package/wasm-opt) tool optimizes some instruction sequences and removes any unnecessary sections—such as the ones for debugging—to create a compact WebAssembly binary.
- The runtime crate is added as a dependency of the node.

### Compress and embed the optimized binary

- A [zstd lossless compression](https://en.wikipedia.org/wiki/Zstandard) algorithm is applied to minimize the size of the final WebAssembly binary.
- The `runtime/src/lib.rs` file for the node requires the WebAssembly blob from the first step and embeds it into its compilation result.
- The final executable binary is generated for the project.

At each stage of the build process, the WebAssembly binary is compressed to a smaller and smaller size.
For example, you can compare the sizes of each WebAssembly binary artifact for Polkadot:

```bash
.rw-r--r-- 1.2M pep  1 Dec 16:13 │  ├── polkadot_runtime.compact.compressed.wasm
.rw-r--r-- 5.1M pep  1 Dec 16:13 │  ├── polkadot_runtime.compact.wasm
.rwxr-xr-x 5.5M pep  1 Dec 16:13 │  └── polkadot_runtime.wasm
```

You should always use the fully compressed runtime (`*_runtime.compact.compressed.wasm`) WebAssembly binaries for on-chain upgrades and relay chain validation.
In most cases, there's no need to use the initial WebAssembly binary or interim compact artifacts.

The build.rs file needs to contain the following code:

use substrate_wasm_builder::WasmBuilder;

fn main() {
    WasmBuilder::new()
        // Tell the builder to build the project (crate) this `build.rs` is part of.
        .with_current_project()
        // Make sure to export the `heap_base` global, this is required by Substrate
        .export_heap_base()
        // Build the Wasm file so that it imports the memory (need to be provided by at instantiation)
        .import_memory()
        // Build it.
        .build()
}
As the final step, you need to add the following to your project:

include!(concat!(env!("OUT_DIR"), "/wasm_binary.rs"));
This will include the generated Wasm binary as two constants WASM_BINARY and WASM_BINARY_BLOATY. The former is a compact Wasm binary and the latter is the Wasm binary as being generated by the compiler. Both variables have Option<&'static [u8]> as type.

Features
Wasm builder supports to enable cargo features while building the Wasm binary. By default it will enable all features in the wasm build that are enabled for the native build except the default and std features. Besides that, wasm builder supports the special runtime-wasm feature. This runtime-wasm feature will be enabled by the wasm builder when it compiles the Wasm binary. If this feature is not present, it will not be enabled.

Environment variables
By using environment variables, you can configure which Wasm binaries are built and how:

SKIP_WASM_BUILD - Skips building any Wasm binary. This is useful when only native should be recompiled. If this is the first run and there doesn't exist a Wasm binary, this will set both variables to None.
WASM_BUILD_TYPE - Sets the build type for building Wasm binaries. Supported values are release or debug. By default the build type is equal to the build type used by the main build.
FORCE_WASM_BUILD - Can be set to force a Wasm build. On subsequent calls the value of the variable needs to change. As wasm-builder instructs cargo to watch for file changes this environment variable should only be required in certain circumstances.
WASM_BUILD_RUSTFLAGS - Extend RUSTFLAGS given to cargo build while building the wasm binary.
WASM_BUILD_NO_COLOR - Disable color output of the wasm build.
WASM_TARGET_DIRECTORY - Will copy any build Wasm binary to the given directory. The path needs to be absolute.
WASM_BUILD_TOOLCHAIN - The toolchain that should be used to build the Wasm binaries. The format needs to be the same as used by cargo, e.g. nightly-2020-02-20.
CARGO_NET_OFFLINE - If true, --offline will be passed to all processes launched to prevent network access. Useful in offline environments.
Each project can be skipped individually by using the environment variable SKIP_PROJECT_NAME_WASM_BUILD. Where PROJECT_NAME needs to be replaced by the name of the cargo project, e.g. node-runtime will be NODE_RUNTIME.

-----
## Execution strategies

After you have compiled the node with the Rust and Wasm runtime, you use command-line options to specify how the node should operate.
For details about the command-line options you can use to start the node, see the [node-template](/reference/command-line-tools/node-template) command-line reference.

When you start the node, the node executable uses the command-line options you specify to initialize the chain and generate the genesis block.
As part of this process, the node adds the Wasm runtime as a storage item value and a corresponding `:code` key.

After you start the node, the running node selects the runtime execution environment to use.
The execution environment selected is controlled by a configurable **execution strategy**.
These strategies are defined in the [`ExecutionStrategy`](/rustdocs/latest/sp_state_machine/enum.ExecutionStrategy.html) enum and specify the following execution rules:

- `NativeWhenPossible`: Execute with the Rust runtime if it's available, or WebAssembly if it's not.
- `AlwaysWasm`: Only execute with the WebAssembly runtime.
- `Both`: Execute with both the Rust runtime (where available) and WebAssembly runtime.
- `NativeElseWasm`: Only execute with the WebAssembly runtime if execution with the Rust runtime fails.

### Default execution strategies

By default, different parts of the blockchain execution process use the following execution strategies:

| Operation | Default strategy
| --------- | ----------------
| Syncing | NativeElseWasm
| Block import for non-validator nodes | NativeElseWasm
| Block import for validator nodes | AlwaysWasm
| Block authoring | AlwaysWasm
| Offchain and other operations | NativeWhenPossible

### Selection of the WebAssembly runtime

The execution strategy is important because the two representations of the runtime can be different.
For example, if you make changes to the runtime, you must generate a new WebAssembly blob and update the chain to use the new version of the WebAssembly runtime.
After the update, the WebAssembly runtime differs from the Rust runtime.
To account for this difference, all of the execution strategies treat the WebAssembly representation of the runtime as the canonical runtime.
If the Rust runtime and the WebAssembly runtime versions are different, the WebAssembly runtime is always selected.

Because the WebAssembly runtime is stored as part of the blockchain state, the network must come to consensus about the representation of this binary.
To reach consensus about the binary, the blob that represents the WebAssembly runtime must be exactly the same across all synchronizing nodes.

### WebAssembly execution environment

The WebAssembly execution environment can be more restrictive than the Rust execution environment.
For example, the WebAssembly execution environment is a 32-bit architecture with a maximum 4GB of memory.
Logic that can be executed in the WebAssembly runtime can always be executed in the Rust execution environment.
However, not all logic that can be executed in the Rust runtime can be executed in the WebAssembly runtime.
Block authoring nodes typically use the WebAssembly execution environment to help ensure that they produce valid blocks.

### Rust execution environment

As noted in [Default execution strategies](#default-execution-strategies), the Rust execution environment is used in some parts of the block handling process.
However, this is only true if the Rust execution environment is compatible with the WebAssembly [runtime version](/main-docs/build/upgrade/#runtime-versioning).

For most execution processes—except block authoring—the Rust execution environment is preferred because it provides better performance and has fewer restriction.
However, you can override the default execution strategy for ny part of the block handling process by specifying command-line options.
For example, if you want to use the Rust execution environment for block authoring, you can specify add `--execution-block-construction Native` to the command you use to start a node.

## Building WebAssembly without a native runtime

A WebAssembly runtime is required to start a new chain.
After an initial WebAssembly runtime is provided, the blob that represents the WebAssembly runtime can be passed to other nodes as part of a [chain specification](/main-docs/build/chain-spec).
In some rare cases, you might want to compile the WebAssembly target without the native runtime.
For example, if you're testing a WebAssembly runtime to prepare for a forkless upgrade, you might want to compile just the new WebAssembly binary.

Although it's a rare use case, you can use the [build-only-wasm.sh](https://github.com/paritytech/substrate/blob/master/.maintain/build-only-wasm.sh) script to build the `no_std` WebAssembly binary without compiling the native runtime.

You can also use the `wasm-runtime-overrides` command-line option to load the WebAssembly from the file system.

Usually when performing a runtime upgrade, you want to provide both a native and Wasm binary.

## Compiling Rust without WebAssembly

If you want to compile the Rust code for a node without building a new WebAssembly runtime, you can use the `SKIP_WASM_BUILD` as a build option.
This option is primarily used for faster compile time when you don't need to update the WebAssembly.

## Where to go next

- [Wasm-builder README](https://github.com/paritytech/substrate/blob/master/utils/wasm-builder/README.md)
- [Rust compilation options](https://doc.rust-lang.org/cargo/commands/cargo-build.html#compilation-options)
- [Discussion: Removing the native runtime](https://github.com/paritytech/substrate/issues/10579)