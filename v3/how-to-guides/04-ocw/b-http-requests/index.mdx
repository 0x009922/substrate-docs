---
title: Making HTTP Requests
slug: /how-to-guides/v3/ocw/http-requests
keywords: ['off-chain worker', 'ocw', 'http', 'https', 'requests']
version: '3.0'
section: how to guides
category: ocw
---

Making HTTP Requests

<Objectives data={[
  {
    title: 'Goal',
    description: `Send HTTP requests offchain.`
  },
  {
    title: 'Use Cases',
    description: `GET data from offchain, or POST data offchain.`,
  },
]}/>

## Overview

The offchain-worker (**ocw** for short)  was introduced to simplify the building of oracles. Because a blockchain does not have access to data outside its own network, an oracle is required to provide context on decision Making

In this chapter we will look through retreiving/submitting data via an API. 

Remember that although Rust provides various libraries that allow you to issue HTTP requests, the OCW runs in an [no-std](https://docs.rust-embedded.org/book/intro/no-std.html) environment, luckily Substrate provides us a few libraries we can use to issue HTTP requests to an API. 

### Supported Methods
The Substrate HTTP library supports the following methods:
- GET
- POST
- PUT
- PATCH
- DELETE


## Get request

1. Define a request block
  ```rust
        // We want to keep the offchain worker execution time reasonable, so we set a hard-coded
		// deadline to 2s to complete the external call.
		// You can also wait idefinitely for the response, however you may still get a timeout
		// coming from the host machine.
		let deadline = sp_io::offchain::timestamp().add(Duration::from_millis(2_000));

        // Initiate an external HTTP GET request.
		// This is using high-level wrappers from `sp_runtime`, for the low-level calls that
		// you can find in `sp_io`. The API is trying to be similar to `request`, but
		// since we are running in a custom WASM execution environment we can't simply
		// import the library here.
		let request = http::Request::get("https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD");
		// We set the deadline for sending the request but awaiting a response can
		// have a separate deadline. Next we send the request, before that it's also possible
		// to alter request headers or stream body content in case of non-GET requests.
		let pending = request.deadline(deadline).send().map_err(|_| http::Error::IoError)?;

		// The request is already being processed by the host, we are free to do anything
		// else in the worker (we can send multiple concurrent requests too).
		// At some point however we probably want to check the response though,
		// so we can block current thread and wait for it to finish.
		// Note that since the request is being driven by the host, we don't have to wait
		// for the request to have it complete, we will just not read the response.
		let response = pending.try_wait(deadline).map_err(|_| http::Error::DeadlineReached)??;
		// Let's check the status code before we proceed to reading the response.
		if response.code != 200 {
			log::warn!("Unexpected status code: {}", response.code);
			return Err(http::Error::Unknown)
		}

		// Next we want to fully read the response body and collect it to a vector of bytes.
		// Note that the return object allows you to read the body in chunks as well
		// with a way to control the deadline.
		let body = response.body().collect::<Vec<u8>>();

		// Create a str slice from the body.
		let body_str = sp_std::str::from_utf8(&body).map_err(|_| {
			log::warn!("No UTF8 body");
			http::Error::Unknown
		})?;
  
  ```

Next up, we will work on submitting data to an API. This could be useful for pushing data existing in the blockchain offchain

## Post request

1. Define a request block
  ```rust
       
        fn submit_http_post_request(
        url: Vec<u8>,
        request_body: Vec<u8>,
    ) -> Result<Vec<u8>, http::Error> {
        // Establish deadline
        let deadline = sp_io::offchain::timestamp().add(Duration::from_millis(10_000));

        let request =
            http::Request::post(str::from_utf8(&url).unwrap(), vec![request_body.clone()])
                .add_header("x-api-key", "test_api_key")
                .add_header("content-type", "application/json");

        // Send post request
        let pending = request
            .deadline(deadline)
            .body(vec![request_body.clone()])
            .send()
            .map_err(|_| http::Error::IoError)?;

        // Wait for response
        let response = pending
            .try_wait(deadline)
            .map_err(|_| http::Error::DeadlineReached)??;

        // Check status code
        if response.code != 200 {
            log::info!("Unexpected status code: {}", response.code);
            return Err(http::Error::Unknown);
        }

        // Collect body
        let body = response.body().collect::<Vec<u8>>();
        let body_str = sp_std::str::from_utf8(&body).map_err(|_| {
            log::info!("No UTF8 body");
            http::Error::Unknown
        })?;

        Ok(body_str.as_bytes().to_vec())
    }
  
  ```

## Examples

- [**Offchain Worker Example Pallet** in Substrate](https://github.com/paritytech/substrate/blob/monthly-2021-12/frame/examples/offchain-worker/src/lib.rs#L568-#L621)
- [**OCW Pallet** in Substrate Offchain Worker Demo](https://github.com/jimmychu0807/substrate-offchain-worker-demo/blob/master/pallets/ocw/src/lib.rs#L363-#L401)
- [**Offchain HTTP source** in Substrate Core](https://github.com/paritytech/substrate/blob/master/primitives/runtime/src/offchain/http.rs#L63-L76)