---
title: Making Transactions
slug: /how-to-guides/v3/ocw/transactions
keywords:
  - off-chain worker
  - ocw
  - transactions
version: '3.0'
section: how to guides
category: ocw
---

<Objectives data={[
  {
    title: 'Goal',
    description: `Learn how to perform the following actions from off-chain workers:
- Signed transactions
- Unsigned transactions
- Unsigned transactions with signed payload`
  },
  {
    title: 'Use Cases',
    description: `Data processed from off-chain workers cannot be saved in on-chain storage
    directly. To do so, a transaction must be sent on-chain from off-chain workers. Here we
    introduce three ways of doing that.`,
  },
]}/>

## Overview

You have used off-chain workers fetching some valuable data, or processing some very crucial data.
Now you want to save it on-chain. How do you go about that? In this how-to guide, we will introduce
three methods to do that.

- **Signed transactions** - use this when you want to record the associated transaction caller
  and deduct the transaction fee from the caller account.
- **Unsigned transactions** - use this when you **DO NOT** want to record the associated caller.
- **Unsigned transactions with signed payload** - use this when you want to record the associated transaction caller, but do not want the caller be responsible for the transaction fee payment.

## Steps: sending signed transactions

1. In your pallet, call the hook of off-chain workers as follows:

  ```rust
  #[pallet::hooks]
  impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
    /// Offchain Worker entry point.
    ///
    /// By implementing `fn offchain_worker` you declare a new offchain worker.
    /// This function will be called when the node is fully synced and a new best block is
    /// succesfuly imported.
    /// Note that it's not guaranteed for offchain workers to run on EVERY block, there might
    /// be cases where some blocks are skipped, or for some the worker runs twice (re-orgs),
    /// so the code should be able to handle that.
    fn offchain_worker(block_number: T::BlockNumber) {
      log::info!("Hello from pallet-ocw.");
      // The entry point of your code called by off-chain worker
    }
    // ...
  }
  ```

2. Your pallet trait Config need to be bound by [`CreateSignedTransaction` trait](https://paritytech.github.io/substrate/latest/frame_system/offchain/trait.CreateSignedTransaction.html).
  So your pallet `Config` trait will look like:

  ```rust
  /// This pallet's configuration trait
  #[pallet::config]
  pub trait Config: CreateSignedTransaction<Call<Self>> + frame_system::Config {
    // ...
  }
  ```

3. To ensure your pallet owns an account that can be used for signing transactions, we will add a `crypto` module with a sr25519 signature key in the pallet.

  ```rust
  use sp_core::{crypto::KeyTypeId};

  // ...

  pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"demo");

  // ...

  pub mod crypto {
    use super::KEY_TYPE;
    use sp_core::sr25519::Signature as Sr25519Signature;
    use sp_runtime::{
      app_crypto::{app_crypto, sr25519},
      traits::Verify, MultiSignature, MultiSigner
    };
    app_crypto!(sr25519, KEY_TYPE);

    pub struct TestAuthId;

    // implemented for runtime
    impl frame_system::offchain::AppCrypto<MultiSigner, MultiSignature> for TestAuthId {
      type RuntimeAppPublic = Public;
      type GenericSignature = sp_core::sr25519::Signature;
      type GenericPublic = sp_core::sr25519::Public;
    }
  }
  ```

  The [`app_crypto` macro](https://paritytech.github.io/substrate/latest/sp_application_crypto/macro.app_crypto.html) above declares an account with sr25519 signature that is identified by
  `KEY_TYPE`. Note that this doesn't create a new account, but just declaring that a crypto account
  is available for this pallet. We need to initialize this account later. More on this at the
  following.

4. Now, you could send a signed transaction on-chain by first getting a signer.

  ```rust
  fn offchain_worker(block_number: T::BlockNumber) {
    let signer = Signer::<T, T::AuthorityId>::all_accounts();

    // ...
  }
  ```

  Although it is calling `all_accounts()`, we will only inject one account into this pallet later
  defined above in the `crypto` module.

  Then we can send an extrinsic call in `send_signed_transaction()`:

  ```rust
  fn offchain_worker(block_number: T::BlockNumber) {
    let signer = Signer::<T, T::AuthorityId>::all_accounts();

    // Using `send_signed_transaction` associated type we create and submit a transaction
    // representing the call we've just created.
    // `send_signed_transaction()` return type is `Option<(Account<T>, Result<(), ()>)>`. It is:
    //   - `None`: no account is available for sending transaction
    //   - `Some((account, Ok(())))`: transaction is successfully sent
    //   - `Some((account, Err(())))`: error occured when sending the transaction
    let results = signer.send_signed_transaction(|_account| {
      Call::on_chain_call { key: val }
    });

    // ...
  }
  ```

  Lastly, we just need to check if the transaction is successfully submitted on-chain and perform
  proper error handling by checking the returned `results`.

  ```rust
  fn offchain_worker(block_number: T::BlockNumber) {
    // ...

    for (acc, res) in &results {
      match res {
        Ok(()) => log::info!("[{:?}]: submit transaction success.", acc.id),
        Err(e) => log::error!("[{:?}]: submit transaction failure. Reason: {:?}", acc.id, e),
      }
    }

    Ok(())
  }
  ```

5. From pt #2, we have configured the trait bound so that the runtime implementing this
  pallet `Config` trait must also imeplements the `CreateSignedTransaction` trait, so let's
  implement that trait in our runtime.

  Looking at [its rustdocs](https://paritytech.github.io/substrate/latest/frame_system/offchain/trait.CreateSignedTransaction.html),
  we only need to implement the function `create_transaction()` for our runtime. In our
  `runtime/src/lib.rs`:

  ```rust
  impl<LocalCall> frame_system::offchain::CreateSignedTransaction<LocalCall> for Runtime
  where
    Call: From<LocalCall>,
  {
    fn create_transaction<C: frame_system::offchain::AppCrypto<Self::Public, Self::Signature>>(
      call: Call,
      public: <Signature as sp_runtime::traits::Verify>::Signer,
      account: AccountId,
      index: Index,
    ) -> Option<(Call, <UncheckedExtrinsic as sp_runtime::traits::Extrinsic>::SignaturePayload)> {
      let period = BlockHashCount::get() as u64;
      let current_block = System::block_number()
        .saturated_into::<u64>()
        .saturating_sub(1);
      let tip = 0;
      let extra: SignedExtra = (
        frame_system::CheckSpecVersion::<Runtime>::new(),
        frame_system::CheckTxVersion::<Runtime>::new(),
        frame_system::CheckGenesis::<Runtime>::new(),
        frame_system::CheckEra::<Runtime>::from(generic::Era::mortal(period, current_block)),
        frame_system::CheckNonce::<Runtime>::from(index),
        frame_system::CheckWeight::<Runtime>::new(),
        pallet_transaction_payment::ChargeTransactionPayment::<Runtime>::from(tip),
      );

      let raw_payload = SignedPayload::new(call, extra)
        .map_err(|e| {
          log::warn!("Unable to create signed payload: {:?}", e);
        })
        .ok()?;
      let signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;
      let address = account;
      let (call, extra, _) = raw_payload.deconstruct();
      Some((call, (sp_runtime::MultiAddress::Id(address), signature.into(), extra)))
    }
  }
  ```

  The above code seems long, but what it tries to do is really:

    - Create and prepare `extra` of `SignedExtra` type, and put various checkers in-place.
    - Create a raw payload based on the passed in `call` and `extra`.
    - Sign the raw payload with the account public key.
    - Finally, bundle all data up and return a tuple of the call, the caller, its signature, and
      any signed extension data.

  A full exmaple code can be seen [in the **Substrate** code base](https://github.com/paritytech/substrate/blob/monthly-2021-12/bin/node/runtime/src/lib.rs#L960-L999).

6. The runtime also needs to implement `SigningTypes` and `SendTransactionTypes` in order to submit
  transactions, whether signed or unsigned.

  ```rust
  impl frame_system::offchain::SigningTypes for Runtime {
    type Public = <Signature as sp_runtime::traits::Verify>::Signer;
    type Signature = Signature;
  }

  impl<C> frame_system::offchain::SendTransactionTypes<C> for Runtime
  where
    Call: From<C>,
  {
    type OverarchingCall = Call;
    type Extrinsic = UncheckedExtrinsic;
  }
  ```

  An example of this implementation can be seen [in the **Substrate** code base](https://github.com/paritytech/substrate/blob/monthly-2021-12/bin/node/runtime/src/lib.rs#L1001-L1012).

7. Now back to pt #3, we need to assign an account this pallet owned. In developemnt environment
  (node running with `--dev` flag), this account key is [inserted in `node/src/service.rs`](https://github.com/jimmychu0807/substrate-offchain-worker-demo/blob/v2.0.0/node/src/service.rs#L87-L105)
  as follows:

  ```rust
  pub fn new_partial(config: &Configuration) -> Result <SomeStruct, SomeError> {

    //...

    if config.offchain_worker.enabled {
      // Initialize seed for signing transaction using off-chain workers. This is a convenience
      // so learners can see the transactions submitted simply running the node.
      // Typically these keys should be inserted with RPC calls to `author_insertKey`.
      sp_keystore::SyncCryptoStore::sr25519_generate_new(
        &*keystore,
        node_template_runtime::pallet_your_ocw_pallet::KEY_TYPE,
        Some("//Alice"),
      ).expect("Creating key with account Alice should succeed.");
    }
  }
  ```

  In the above code, we are injecting `Alice` key in the crypto store identified by our pallet
  defined `KEY_TYPE`.

  Now, your pallet is ready to send signed transactions on-chain from off-chain workers.

## Steps: sending unsigned transactions

1. By default all unsigned transactions are rejected in Substrate. So we first need to allow
  certain unsigned transactions we want to accept. This can be done by having the pallet implements
  the `ValidateUnsigned` trait. In our pallet `src/lib.rs`:

  ```rust
  #[pallet::validate_unsigned]
  impl<T: Config> ValidateUnsigned for Pallet<T> {
    type Call = Call<T>;

    /// Validate unsigned call to this module.
    ///
    /// By default unsigned transactions are disallowed, but implementing the validator
    /// here we make sure that some particular calls (the ones produced by offchain worker)
    /// are being whitelisted and marked as valid.
    fn validate_unsigned(source: TransactionSource, call: &Self::Call) -> TransactionValidity {
      //...
    }
  }
  ```

  First, we call the [`validate_unsigned` pallet macro](https://paritytech.github.io/substrate/latest/frame_support/attr.pallet.html#validate-unsigned-palletvalidate_unsigned-optional), and then
  imeplement the trait.

  ```rust
  fn validate_unsigned(source: TransactionSource, call: &Self::Call) -> TransactionValidity {
    let valid_tx = |provide| ValidTransaction::with_tag_prefix("my-pallet")
      .priority(UNSIGNED_TXS_PRIORITY) // please define `UNSIGNED_TXS_PRIORITY` before this line
      .and_provides([&provide])
      .longevity(3)
      .propagate(true)
      .build();
    // ...
  }
    ```

  Inside the `validate_unsigned()` function we create a convenient method `valid_tx` that returns
  `TransactionValidity`. Next, we check the calling extrinsics, if it is a call that we allow,
  we return a `ValidTransaction`, otherwise a `TransactionValidityError` is returned.

  ```rust
  fn validate_unsigned(source: TransactionSource, call: &Self::Call) -> TransactionValidity {
    // ...
    match call {
      Call::extrinsic1 { key: value } => valid_tx(b"extrinsic1".to_vec()),
      _ => InvalidTransaction::Call.into(),
    }
  }
  ```

  With the above example code, users can call on-chain `extrinsic1` without signature, but not any
  other extrinsics.

  To see a full example of how `ValidateUnsigned` is implemented in a pallet, refer to
  [`pallet-ocw` in **Substrate Off-chain Worker Demo**](https://github.com/jimmychu0807/substrate-offchain-worker-demo/blob/v2.0.0/pallets/ocw/src/lib.rs#L209-L240)
  and [`pallet-example-offchain-worker` in **Substrate**](https://github.com/paritytech/substrate/blob/monthly-2021-12/frame/examples/offchain-worker/src/lib.rs#L297-L325).

2. Now in the off-chain worker function, we can make unsigned transactions as follow.

  ```rust
  #[pallet::hooks]
  impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
    /// Offchain Worker entry point.
    fn offchain_worker(block_number: T::BlockNumber) {
      let value: u64 = 10;
      // This is your call to on-chain extrinsic together with any necessary parameters.
      let call = Call::unsigned_extrinsic1 { key: value };

      // `submit_unsigned_transaction` returns a type of `Result<(), ()>`
      //   ref: https://paritytech.github.io/substrate/latest/frame_system/offchain/struct.SubmitTransaction.html
      SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into())
        .map_err(|_| {
          log::error!("Failed in offchain_unsigned_tx");
        });
    }
  }
  ```

  In the above code, we first prepare our call in the `let call = ...` line. Then we submit the
  transaction using [`SubmitTransaction::submit_unsigned_transaction`](https://paritytech.github.io/substrate/latest/frame_system/offchain/struct.SubmitTransaction.html)
  and perform any necessary error handling in the callback function passed in.

3. To enable `ValidateUnsigned` trait for our pallet in the runtime, we need to notify that in our
  `construct_runtime` macro when defining the pallet variant by passing a `ValidateUnsigned` type.

  ```rust
  construct_runtime!(
    pub enum Runtime where
      Block = Block,
      NodeBlock = opaque::Block,
      UncheckedExtrinsic = UncheckedExtrinsic
    {
      // ...
      OcwPallet: pallet_ocw::{Pallet, Call, Storage, Event<T>, ValidateUnsigned},
    }
  );
  ```

4. We will need to implement `SendTransactionTypes` trait for the runtime. This is the same as the
  implementation used for [sending signed transactions](#steps-sending-signed-transactions) in
  pt #6 above.

A full example can be seen [in `pallet-example-offchain-worker` in **Substrate** code base](https://github.com/paritytech/substrate/blob/monthly-2021-12/frame/examples/offchain-worker).

## Steps: sending unsigned transactions with signed payloads

This approach is more or less the same as sending unsigned transactions in the above. We need to:

- Implement the `ValidateUnsigned` trait for the pallet.
- Passing the `ValidateUnsigned` type in our Runtime variant when using this pallet

You can refer to the instructions in the above. Let's see the major differences now.

1. We are going to prepare the data structure that is going to be signed (known as the signed
  payload). This payload needs to implement  [`SignedPayload` trait](https://paritytech.github.io/substrate/latest/frame_system/offchain/trait.SignedPayload.html).
  Let's use a simple example as follows:

  ```rust
  #[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, scale_info::TypeInfo)]
  pub struct Payload<Public> {
    number: u64,
    public: Public,
  }

  impl<T: SigningTypes> SignedPayload<T> for Payload<T::Public> {
    fn public(&self) -> T::Public {
      self.public.clone()
    }
  }
  ```

  An example can be seen [here](https://github.com/paritytech/substrate/blob/monthly-2021-12/frame/examples/offchain-worker/src/lib.rs#L344-L357).

2. Now within the pallet off-chain worker function, we can send the transaction this way:

  ```rust
  #[pallet::hooks]
  impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
    /// Offchain Worker entry point.
    fn offchain_worker(block_number: T::BlockNumber) {
      let value: u64 = 10;

      // Retrieve the signer to sign the payload
      let signer = Signer::<T, T::AuthorityId>::any_account();

      // `send_unsigned_transaction` is returning a type of `Option<(Account<T>, Result<(), ()>)>`.
      //   The returned result means:
      //   - `None`: no account is available for sending transaction
      //   - `Some((account, Ok(())))`: transaction is successfully sent
      //   - `Some((account, Err(())))`: error occured when sending the transaction
      if let Some((_, res)) = signer.send_unsigned_transaction(
        // this line is to prepare and return payload
        |acct| Payload { number, public: acct.public.clone() },
        |payload, signature| Call::some_extrinsics { payload, signature },
      ) {
        match res {
          Ok(()) => log::info!("unsigned tx with signed payload successfully sent.");
          Err(()) => log::error!("sending unsigned tx with signed payload failed.");
        };
      } else {
        // The case of `None`: no account is available for sending
        log::error!("No local account available");
      }
    }
  }
  ```

  In the above code snippet, we fetch the `signer` and then call `send_unsigned_transaction()`.
  It accepts two function closures. The first one returns the payload to be used, and the second
  one returns the on-chain call with payload and signature passed in. This call returns a
  `Option<(Account<T>, Result<(), ()>)>` result type, which carry the meaning:

    * `None`: no account is available for sending transaction
    * `Some((account, Ok(())))`: transaction is successfully sent
    * `Some((account, Err(())))`: error occured when sending the transaction

3. Lastly, you may have a more complex `ValidateUnsigned` logic to check the provided signature
  does match with the public key signing the payload. You can do that with the following logics
  in the `ValidateUnsigned` implementation.

  ```rust
  #[pallet::validate_unsigned]
  impl<T: Config> ValidateUnsigned for Pallet<T> {
    type Call = Call<T>;

    fn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {
      let valid_tx = |provide| ValidTransaction::with_tag_prefix("ocw-demo")
        .priority(UNSIGNED_TXS_PRIORITY)
        .and_provides([&provide])
        .longevity(3)
        .propagate(true)
        .build();

      match call {
        Call::unsigned_extrinsic_with_signed_payload {
          ref payload,
          ref signature
        } => {
          if !SignedPayload::<T>::verify::<T::AuthorityId>(payload, signature.clone()) {
            return InvalidTransaction::BadProof.into();
          }
          valid_tx(b"unsigned_extrinsic_with_signed_payload".to_vec())
        },
        _ => InvalidTransaction::Call.into(),
      }
    }
  }
  ```

  We have seen most of the above code before. The new code is that we use
  [`SignedPayload`](https://paritytech.github.io/substrate/latest/frame_system/offchain/trait.SignedPayload.html?search=SignedPayload)
  to verify the payload (which contains the public key) has the same signature as the one provided.

A full example of [the off-chain function call](https://github.com/paritytech/substrate/blob/monthly-2021-12/frame/examples/offchain-worker/src/lib.rs#L505-L532)
and [`ValidateUnsigned` implementation](https://github.com/paritytech/substrate/blob/monthly-2021-12/frame/examples/offchain-worker/src/lib.rs#L308-L318)
can be seen.

---

Whew! This is a long chapter. But congratulation! By now you should be able to use off-chain workers
to send data on-chain using:

- Signed transactions
- Unsigned transactions
- Unsigned transactions with signed payload

## Examples

- [Substrate Offchain Worker Example Pallet](https://github.com/paritytech/substrate/tree/monthly-2021-12/frame/examples/offchain-worker)
- [OCW Pallet in Substrate Offchain Worker Demo](https://github.com/jimmychu0807/substrate-offchain-worker-demo/tree/v2.0.0/pallets/ocw)

## Related material

- [Concept: Off-Chain Features](/v3/concepts/off-chain-features/)
