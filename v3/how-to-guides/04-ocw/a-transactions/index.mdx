---
title: Making Transactions
slug: /how-to-guides/v3/ocw/transactions
keywords:
  - off-chain worker
  - ocw
  - transactions
version: '3.0'
section: how to guides
category: ocw
---

<Objectives data={[
  {
    title: 'Goal',
    description: `Learn how to perform the following from off-chain workers:
- signed transactions
- unsigned transactions
- unsigned transactions with signed payload`
  },
  {
    title: 'Use Cases',
    description: `Data processed or fetched from off-chain workers is not saved directly on-chain. To do so, a transaction must be sent on-chain from off-chain workers. Here we introduce three ways of doing that.`,
  },
]}/>

## Overview

You have used off-chain workers fetching some valuable data, or processing some very conclusive data. Now you want to save it on-chain. How do you go about that? Here, we introduce three methods:

- **Signed transactions** - use this when you want to record the associated transaction caller and deducting the transaction fee from the caller account.
- **Unsigned transactions** - use this when you **DO NOT** want to record the associated caller.
- **Unsigned transactions with signed payload** - use this when you want to record the associated transaction caller, but do not want the caller be responsible for the transaction fee payment.

## Steps for signed transactions

1. Call the life-cycle hook of off-chain workers in your pallet, as follows:

  ```rust
  #[pallet::hooks]
  impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
    /// Offchain Worker entry point.
    ///
    /// By implementing `fn offchain_worker` you declare a new offchain worker.
    /// This function will be called when the node is fully synced and a new best block is
    /// succesfuly imported.
    /// Note that it's not guaranteed for offchain workers to run on EVERY block, there might
    /// be cases where some blocks are skipped, or for some the worker runs twice (re-orgs),
    /// so the code should be able to handle that.
    /// You can use `Local Storage` API to coordinate runs of the worker.
    fn offchain_worker(block_number: T::BlockNumber) {
      log::info!("Hello from pallet-ocw.");
      // The entry point of your code called by off-chain worker
    }
    // ...
  }
  ```

2. Your pallet trait Config need to be bound by [`CreateSignedTransaction` trait](https://paritytech.github.io/substrate/latest/frame_system/offchain/trait.CreateSignedTransaction.html). So your `Config` trait will look like:

  ```rust
  /// This pallet's configuration trait
  #[pallet::config]
  pub trait Config: CreateSignedTransaction<Call<Self>> + frame_system::Config {
    // ...
  }
  ```

3. To ensure your pallet owns an account that can be used for signing transactions, we will add a `crypto` module with a sr25519 signature key.

  ```rust
  pub mod crypto {
    use super::KEY_TYPE;
    use sp_core::sr25519::Signature as Sr25519Signature;
    use sp_runtime::{
      app_crypto::{app_crypto, sr25519},
      traits::Verify, MultiSignature, MultiSigner
    };
    app_crypto!(sr25519, KEY_TYPE);

    pub struct TestAuthId;

    // implemented for runtime
    impl frame_system::offchain::AppCrypto<MultiSigner, MultiSignature> for TestAuthId {
      type RuntimeAppPublic = Public;
      type GenericSignature = sp_core::sr25519::Signature;
      type GenericPublic = sp_core::sr25519::Public;
    }
  }
  ```

  The [`app_crypto` macro](https://paritytech.github.io/substrate/latest/sp_application_crypto/macro.app_crypto.html) above declares an account using sr25519 logic that is identified by `KEY_TYPE`. Note that this doesn't create a new account, but just declaring a crypto account is available for this pallet. More on this at the following.

4. Now, you could send a signed transaction on-chain by first getting a signer.

  ```rust
  let signer = Signer::<T, T::AuthorityId>::all_accounts();
  ```

  Although it is calling `all_accounts()`, there is only one account owned by this pallet, defined above in the `crypto` module.

  Then we can send the wrap an extrinsic call in `send_signed_transaction()`:

  ```rust
  // Using `send_signed_transaction` associated type we create and submit a transaction
  // representing the call, we've just created.
  // Submit signed will return a vector of results for all accounts that were found in the
  // local keystore with expected `KEY_TYPE`.
  let results = signer.send_signed_transaction(|_account| {
    Call::on_chain_call { key: val }
  });
  ```

  Lastly, we just need to check if the transaction is successfully submitted on-chain and perform proper error handling.

  ```rust
  for (acc, res) in &results {
    match res {
      Ok(()) => log::info!("[{:?}]: submit transaction success.", acc.id),
      Err(e) => log::error!("[{:?}]: submit transaction failure. Reason: {:?}", acc.id, e),
    }
  }
  ```

  For a full example on how to send a signed transaction on-chain, refer to [this function](https://github.com/jimmychu0807/substrate-offchain-worker-demo/blob/v2.0.0/pallets/example-offchain-worker/src/lib.rs#L437-L467) in [Substrate Off-chain Worker Demo](https://github.com/jimmychu0807/substrate-offchain-worker-demo).

5. Now we need to configure which account does this pallet owned. In developemnt environment (node running with `--dev` flag), the key is [inserted in `node/src/service.rs`](https://github.com/jimmychu0807/substrate-offchain-worker-demo/blob/v2.0.0/node/src/service.rs#L87-L105) at the following:

  ```rust
  pub fn new_partial(config: &Configuration) -> Result <SomeStruct, SomeError> {
    //...
    if config.offchain_worker.enabled {
      // Initialize seed for signing transaction using off-chain workers. This is a convenience
      // so learners can see the transactions submitted simply running the node.
      // Typically these keys should be inserted with RPC calls to `author_insertKey`.
      sp_keystore::SyncCryptoStore::sr25519_generate_new(
        &*keystore,
        node_template_runtime::pallet_example_offchain_worker::KEY_TYPE,
        Some("//Alice"),
      ).expect("Creating key with account Alice should succeed.");
    }
  }
  ```

6. From pt #1, to implement this pallet `Config` trait, the runtime also need to imeplement the `CreateSignedTransaction` trait. So let's also implement that in our runtime:

  ```rust
  impl<LocalCall> frame_system::offchain::CreateSignedTransaction<LocalCall> for Runtime
  where
    Call: From<LocalCall>,
  {
    fn create_transaction<C: frame_system::offchain::AppCrypto<Self::Public, Self::Signature>>(
      call: Call,
      public: <Signature as sp_runtime::traits::Verify>::Signer,
      account: AccountId,
      index: Index,
    ) -> Option<(Call, <UncheckedExtrinsic as sp_runtime::traits::Extrinsic>::SignaturePayload)> {
      let period = BlockHashCount::get() as u64;
      let current_block = System::block_number()
        .saturated_into::<u64>()
        .saturating_sub(1);
      let tip = 0;
      let extra: SignedExtra = (
        frame_system::CheckSpecVersion::<Runtime>::new(),
        frame_system::CheckTxVersion::<Runtime>::new(),
        frame_system::CheckGenesis::<Runtime>::new(),
        frame_system::CheckEra::<Runtime>::from(generic::Era::mortal(period, current_block)),
        frame_system::CheckNonce::<Runtime>::from(index),
        frame_system::CheckWeight::<Runtime>::new(),
        pallet_transaction_payment::ChargeTransactionPayment::<Runtime>::from(tip),
      );

      let raw_payload = SignedPayload::new(call, extra)
        .map_err(|e| {
          log::warn!("Unable to create signed payload: {:?}", e);
        })
        .ok()?;
      let signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;
      let address = account;
      let (call, extra, _) = raw_payload.deconstruct();
      Some((call, (sp_runtime::MultiAddress::Id(address), signature.into(), extra)))
    }
  }
  ```

7. The runtime also needs to implement `SigningTypes` and `SendTransactionTypes` in order to submit transactions, whether signed or unsigned.

  ```rust
  impl frame_system::offchain::SigningTypes for Runtime {
    type Public = <Signature as sp_runtime::traits::Verify>::Signer;
    type Signature = Signature;
  }

  impl<C> frame_system::offchain::SendTransactionTypes<C> for Runtime
  where
    Call: From<C>,
  {
    type OverarchingCall = Call;
    type Extrinsic = UncheckedExtrinsic;
  }
  ```

  An example of this implementation can be seen [in this example](https://github.com/jimmychu0807/substrate-offchain-worker-demo/blob/v2.0.0/runtime/src/lib.rs#L343-L354).

## Steps for unsigned transactions

1. By default, all unsigned transactions are rejected in Substrate. So we first need to whitelist unsigned transactions we want to accept. This can be done by having the pallet implements the `ValidateUnsigned` trait.

  ```rust
  #[pallet::validate_unsigned]
  impl<T: Config> ValidateUnsigned for Pallet<T> {
    type Call = Call<T>;

    /// Validate unsigned call to this module.
    ///
    /// By default unsigned transactions are disallowed, but implementing the validator
    /// here we make sure that some particular calls (the ones produced by offchain worker)
    /// are being whitelisted and marked as valid.
    fn validate_unsigned(source: TransactionSource, call: &Self::Call) -> TransactionValidity {
      //...
    }
  }
  ```

  Inside the `validate_unsigned()` function, we check if it is a call to our allowed functions we return a `ValidTransaction`, otherwise the `TransactionValidityError`. So, we first create a named closure that helps us return a `ValidTransaction`.

  ```rust
  fn validate_unsigned(source: TransactionSource, call: &Self::Call) -> TransactionValidity {
    let valid_tx = |provide| ValidTransaction::with_tag_prefix("my-pallet")
      .priority(UNSIGNED_TXS_PRIORITY) // please define `UNSIGNED_TXS_PRIORITY` before this line
      .and_provides([&provide])
      .longevity(3)
      .propagate(true)
      .build();
    // ...
  }
    ```

  Next, we check the calling extrinsics,

  ```rust
  fn validate_unsigned(source: TransactionSource, call: &Self::Call) -> TransactionValidity {
    // -- continue
    match call {
      Call::extrinsic1 { key: value } => valid_tx(b"extrinsic1".to_vec()),
      _ => InvalidTransaction::Call.into(),
    }
  }
  ```

  With the above example code, users can call on-chain `extrinsic1` without signature, but not any other extrinsics on-chain.

  To see a full example of how `ValidateUnsigned` is implemented in a pallet, refer to [`pallet-ocw`](https://github.com/jimmychu0807/substrate-offchain-worker-demo/blob/v2.0.0/pallets/ocw/src/lib.rs#L209-L240) and [`pallet-example-offchain-worker`](https://github.com/jimmychu0807/substrate-offchain-worker-demo/blob/v2.0.0/pallets/example-offchain-worker/src/lib.rs#L294-L322).

2. Now in the offchain worker function, you could call the offchain unsigned transactions.

  ```rust
  #[pallet::hooks]
  impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
    /// Offchain Worker entry point.
    fn offchain_worker(block_number: T::BlockNumber) {
      let value: u64 = 10;
      // This is your call to on-chain extrinsic together with any necessary parameters.
      let call = Call::unsigned_extrinsic { key: value };

      // `submit_unsigned_transaction` returns a type of `Result<(), ()>`
      //   ref: https://paritytech.github.io/substrate/latest/frame_system/offchain/struct.SubmitTransaction.html
      SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into())
        .map_err(|_| {
          log::error!("Failed in offchain_unsigned_tx");
        });
    }
  }
  ```

  On the above code, we first prepare our transaction in the `let call = ...` line. Then we submit the transaction using [`SubmitTransaction::submit_unsigned_transaction`](https://paritytech.github.io/substrate/latest/frame_system/offchain/struct.SubmitTransaction.html) and perform necessary error handling in the callback function passed in.

4. To enable `ValidateUnsigned` trait for our runtime, we need to pass this value as a parameter within our `construct_runtime` macro when defining the pallet variant in our `Runtime` enum.

  ```rust
  construct_runtime!(
    pub enum Runtime where
      Block = Block,
      NodeBlock = opaque::Block,
      UncheckedExtrinsic = UncheckedExtrinsic
    {
      OcwDemo: pallet_ocw::{Pallet, Call, Storage, Event<T>, ValidateUnsigned},
    }
  );
  ```

## Steps for unsigned transactions with signed payload

## Examples

## Related material
